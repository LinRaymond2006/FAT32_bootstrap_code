READ_ATA:
	PUSHAD
	%DEFINE PACKETBASE 0X500
	%DEFINE PACKET_HEADER 0X1000
	%DEFINE SECTOR_COUNT (PACKETBASE + 2)
	%DEFINE BUFFER_OFFSET (PACKETBASE + 4)
	%DEFINE BUFFER_SEG (PACKETBASE + 6)
	%DEFINE LOW_LBA_NUMBER (PACKETBASE + 8)
	%DEFINE HIGH_LBA_NUMBER (PACKETBASE + 12)
	
	.SETUP_PACKET:
	MOV WORD [PACKETBASE], PACKET_HEADER
	MOV DWORD [HIGH_LBA_NUMBER], 0

	MOV WORD [BUFFER_OFFSET],BX
	SHR EBX, 16
	MOV WORD [BUFFER_SEG],BX

	MOV WORD [SECTOR_COUNT],CX
	
	;BX=HIGHER PART OF THE ADDRESS(SEGMENT NUMBER)
	;THE EXTENDED REGISTER IS ONLY ABLE TO ADDRESS 32 BIT LBA
	
	MOV DWORD [LOW_LBA_NUMBER], EAX
	MOV DWORD [HIGH_LBA_NUMBER], 0
	
	MOV AH, 0X42
	MOV DL, 0X80	;DRIVE NUMBER
	MOV SI, PACKETBASE
	INT 0X13
	;IF THE CARRY FLAG IS SET, THERE MUST BE AN ERROR, HALT
	;JC $

	POPAD
	RET


NXT_CLUSTER:
	

	;CLUSTER NUMBER STARTS FROM 2
	;THAT IS TO SAY, THE FIRST DATA SECTOR IS CLUSTER 2, AND SO ON.
	;BUT IN THIS FUNCTION, ASSUME CLUSTER NUMBER STARTS FROM 0 (THE FIRST DATA SECTOR IS CLUSTER 0)

	;STEP 1: IF THE FIRST DATA SECTOR IS CLUSTER 0, THAN PLUS 2
	ADD EDX, DWORD [BPB_ROOTCLUS]

	;STEP 2: LOCATE THE NXTCLUS ENTRY IN FAT TABLE 
	;NOW, THE EAX REGISTER IS THE CLUSTER NUMBER (STARTS FROM 2)

	;STEP 2.1: MUL EAX BY 4 ((OPERATOR *4) = (OPERATOR << 2))
	SHL EDX, 2

	;STEP 2.2: EAX = EAX + FATBASE
	ADD EDX, FATBASE

	;STEP 3:EXTRACT THE VALUE OF "NXTCLUSTER", WRITEBACK INTO EAX
	MOV EDX, DWORD [EDX]

	SUB EDX, DWORD [BPB_ROOTCLUS]

	RET


CLUSTER2SECTOR:
	PUSH ECX
	PUSH EDX

	XOR EDX, EDX
	MOVZX ECX, BYTE [BPB_SECPERCLUS]
	MUL CX
	ADD EAX, DWORD [FIRSTDATASECTOR]

	POP EDX
	POP ECX
	RET


CMP_STOP:
	CMP EAX, 0X2
	JGE .IN_VALID_CLUSTERNUM_RANGE
	.IN_VALID_CLUSTERNUM_RANGE:CMP EAX, 0XFFFFFEF
	JBE .RETURN_LABEL	;FINISH READING, RETURN
	.NOT_VALID_COMPARE_EOF: CMP EAX, 0X0F_FF_FF_F8
	JGE .IN_EOF_VALUE_RANGE
	.IN_EOF_VALUE_RANGE: CMP EAX, 0X0F_FF_FF_FF
	JBE .1

	.1:
	;JMP BP
	PUSH BP
	;THAN, RETURN

	.RETURN_LABEL:
	RET