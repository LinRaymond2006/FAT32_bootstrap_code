;FOR FAT32 FILE SYSTEM ON HARD DISK
;CAUSION: THE SECTOR SIZE MUST BE 512
[ORG 0X7C00]
[BITS 16]


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;BPB RESERVED AREA, WOULD NOT BE COPIED WITH DD (USE "SKIP" IN ORDER TO SKIP THOSE)
%INCLUDE "FAT32HEADERS.INC"

;=====GLOBAL=MACROS=====
;ADDRESS-RELATIVE
%DEFINE STACKBASE	0X7C00
%DEFINE BUFFERBASE	0X7E00
%DEFINE TMPBASE		0X500
;ROOT DIRECTORY: 0X7E00~0X100000 (ABLE TO STORE 1985 SECTORS)
%DEFINE ROOTDIRBASE	0X7E00
%DEFINE FATBASE		0X200000
%DEFINE ROOTDIRLIMIT FATBASE

;FAT32-RELATIVE
;LOAD THE ROOTDIR, GET THE FIRST CLUSTER OF THE GIVEN 
;FILE, THAN OVERWRITE THE ROOTDIR REGION WITH FAT TABLE, 
;AND WRITE THE LINKED LIST OF SECTOR NUMBER TO "TMPBASE" IN LOW MEMORY
;0X500, ONCETHOSE STEPS ARE DONE, LOAD THE GIVEN FILE INFO "BUFFERBASE"
;, WHICH IS 0X7E00, RIGHT AFTER THE BOOT SECTOR REGION


%DEFINE SFNSIZE		32

;=======================

[SECTION .CODE]
;=========================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
INIT:
MOV AX, CX
MOV DS, AX
MOV ES, AX
MOV SS, AX
MOV SP, STACKBASE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ENABLE_UNREAL_MODE:
CLI                    ; NO INTERRUPTS
PUSH DS                ; SAVE REAL MODE
LGDT [GDTINFO]         ; LOAD GDT REGISTER
MOV  EAX, CR0          ; SWITCH TO PMODE BY
OR AL,1                ; SET PMODE BIT
MOV  CR0, EAX
JMP $+2                ; TELL 386/486 TO NOT CRASH
MOV  BX, 0X08          ; SELECT DESCRIPTOR 1
MOV  DS, BX            ; 8H = 1000B
AND AL,0XFE            ; BACK TO REALMODE
MOV  CR0, EAX          ; BY TOGGLING BIT AGAIN
POP DS                 ; GET BACK OLD SEGMENT
STI

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CALCULATE_FIRSTDATASECTOR:

;FAT32:
;FIRSTDATASECTOR = BPB_RESVDSECCNT + (BPB_NUMFATS * FATSZ32)

;(BPB_NUMFATS * FATSZ32)
MOV ECX, BPB_FATSZ32
MOV EAX, BPB_NUMFATS
MUL ECX

;+BPB_RESVDSECCNT
MOVZX EDX, WORD [BPB_RESVDSECCNT]
ADD EAX, EDX

;THIS WILL RAISE A "MISMATCH IN OPERAND SIZES" EXCEPTION ON COMPILE TIME
;ADD EAX, WORD [BPB_RESVDSECCNT]


MOV DWORD [FIRSTDATASECTOR], EAX




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LOAD_FATTABLE:
;FUNCTION: "READ_ATA"
;EAX:SECTOR OFFSET
;EBX:BUFFER LOCATION
;CX:NUMBER OF SECTORS TO READ
MOV EAX, BPB_RESVDSECCNT
MOV EBX, FATBASE
MOV CX, BPB_FATSZ32
CALL READ_ATA

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LOAD_ROOTDIR:
;FROM 0X7E00 TO 0X7FFFF, 480KIB IN TOTAL, ABLE TO STORE 960 SECTORS (ASSUME 512 BYTES PER SECTOR)
;LOAD ROOTDIR AND SEARCH FOR THE GIVEN FILE, FAT TABLE IS ALREADY LOADED
;FUNCTION: "READ_ATA"
;EAX:SECTOR OFFSET
;EBX:BUFFER LOCATION
;CX:NUMBER OF SECTORS TO READ

PUSH ROOTDIRBASE
CALL LOAD_FILE

;;;;;;;;;;;;;;;;;;;;;;

LOAD_LOADER:
ADD SP, 4 	;BALANCE THE STACK THAT "LOAD_ROOTDIR" MODIFIED
PUSH BUFFERBASE		;LOADERBASE ACTUALLY

;THE BUFFER IS INSIDE THE FIRST SEGMENT, THEREFORE A SHORT JUMP IS PERFORMED
JMP BUFFERBASE


;=========================
[SECTION .DATA]
GDTINFO:
	DW GDT_END - GDT - 1   ;LAST BYTE IN TABLE
	DD GDT                 ;START OF TABLE

GDT         DD 0,0        ; ENTRY 0 IS ALWAYS UNUSED
FLATDESC    DB 0XFF, 0XFF, 0, 0, 0, 10010010B, 11001111B, 0
GDT_END:

FIRSTDATASECTOR: DD 0

LOADER_FILENAME: DB "LOADER  SYS"

[SECTION SUBROUTINE]
%INCLUDE "MAIN.INC"