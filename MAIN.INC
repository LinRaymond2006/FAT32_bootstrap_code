;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;EAX:SECTOR OFFSET
;EBX:BUFFER LOCATION
;CX:NUMBER OF SECTORS TO READ
%DEFINE BASE_PORT 0X1F0
;0X1F0:ATA0-MASTER
;READING VIA LBA24


READ_ATA:
	PUSHAD
	PUSH EAX
	MOV DI, CX
	MOV DX, BASE_PORT + 2
	MOV AL, CL
	OUT DX, AL 		;HOW MANY SECTORS TO READ
	POP EAX
	MOV DX, BASE_PORT + 3
	OUT DX, AL  	;LBADDR 0~7
	MOV CL, 8
	SHR EAX, CL
	MOV DX, BASE_PORT + 4
	OUT DX, AL  	;LBADDR 8~15
	SHR EAX, CL
	MOV DX, BASE_PORT + 5
	OUT DX, AL  	;LBADDR 16~23
	SHR EAX, CL
	AND AL, 0XE0    ;BIT7~BIT4=1110->USING LBA
	OR AL, 0XE0
	MOV DX, BASE_PORT + 6
	OUT DX, AL
	MOV DX, BASE_PORT + 7
	MOV AL, 0X20
	OUT DX, AL  	;0X20->READ
	.DISKSTAT_BUSY: ;WRITE->COMMAND WORD PORT. READ->DISK STATUS
		NOP
		IN AL, DX
		AND AL, 0X88  ;BIT3=1->READY, BIT7=1->DISK IN BUSY
		CMP AL, 0X08
		JNZ .DISKSTAT_BUSY
		MOV AX, DI
		MOV DX, 256
		MUL DX
		MOV CX, AX
		;DI=LOADER_SECT_SIZE, EACH SECTOR IS COMPOSED BY 512 BYTES
		;THEREFORE NEED DI*512/2 TIMES TO FINISH THE OPERATION(2BYTES COMPRISE A WORD)
		MOV DX, BASE_PORT
	.CONTRD:
		IN AX, DX
		;;;;;;;;;;USE EBX INSTEAD OF BX TO ADDRESS IN UNREAL MODE WITH A20 ENABLED HERE!;;;;;;;;;;;;;;;;;;;;
		MOV [EBX], AX
		ADD EBX, 2
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		LOOP .CONTRD
	POPAD
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;FATBASE HAVE TO BE DEFINED
;EAX:CLUSTER NUMBER (AS A CALLER, THE CLUSTER NUMBER STARTS FROM 0)
;EBX:WHERE TO GO IF RECIEVE "EOF" VALUE

;README:SHOULD EBX FROM CALLEE BE REPLACED WITH EDX?

;RETURNS:
;EAX: THE SECTOR NUMBER OF THE CLUSTER
;EBX:NEXT CLUSTER NUMBER (THE CLUSTER NUMBER STARTS FROM 0)

NXT_CLUSTER:
	
	PUSHAD

	;REGISTER EXCEPT FOR EAX ARE AVAILABLE

	;CLUSTER NUMBER STARTS FROM 2
	;THAT IS TO SAY, THE FIRST DATA SECTOR IS CLUSTER 2, AND SO ON.
	;BUT IN THIS FUNCTION, ASSUME CLUSTER NUMBER STARTS FROM 0 (THE FIRST DATA SECTOR IS CLUSTER 0)

	;STEP 1: IF THE FIRST DATA SECTOR IS CLUSTER 0, THAN PLUS 2
	ADD EAX, BPB_ROOTCLUS

	;STEP 2: LOCATE THE NXTCLUS ENTRY IN FAT TABLE 
	;NOW, THE EAX REGISTER IS THE CLUSTER NUMBER (STARTS FROM 2)

	;STEP 2.1: MUL EAX BY 4 ((OPERATOR *4) = (OPERATOR << 2))
	ROL EAX, 2

	;STEP 2.2: EAX = EAX + FATBASE
	ADD EAX, FATBASE

	;STEP 3:EXTRACT THE VALUE OF "NXTCLUSTER", WRITEBACK INTO EAX
	MOV EAX, DWORD [EAX]




	;STEP 4:COMPARE IF THE VALUE IS A VALID CLUSTER NUMBER

	.CMP_STOP:
		;RECIEVE:
		;EAX:PASSED BY "STEP 3"
		;EBX AS WHERE TO JUMP IF FINISHED (PASSED BY CALLEE OF NXT_CLUSTER, THEREFORE NOT NEED TO BE SET)
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;IF NEXTCLUSTER IS VALID CLUSTER(NOT STOP_SIGNAL): JMP LOADROOTDIR
		;FAT[0]: SAME AS  MEDIA DESCRIPTOR
		;FAT[1]: OCCUPIED
		;FAT[N] VALUE (NOT ALL OF THEM ARE LISTED):
		;	0X0000002~0XFFFFFEF:NEXT CLUSTER
		;	0XFFFFFF8~0XFFFFFFF:EOF	
		CMP EAX, 0X2
		JGE .IN_VALID_CLUSTERNUM_RANGE
		.IN_VALID_CLUSTERNUM_RANGE:CMP EAX, 0XFFFFFEF
		JBE .VALID_CLUSTER_NUMBER	;FINISH READING, RETURN
		.NOT_VALID_COMPARE_EOF: CMP EAX, 0XFFFFFF8
		JGE .IN_EOF_VALUE_RANGE
		.IN_EOF_VALUE_RANGE: CMP EAX, 0XFFFFFFF
		JMP EBX

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	.VALID_CLUSTER_NUMBER:

	;THESE WILL BE EXECUTED IF .CMP_STOP IS PASSED (A VALID DATA CLUSTER VALUE)

	;STEP 5: SUBSTRACT THE VALUE WITH "BPB_ROOTCLUS"
	SUB EAX, BPB_ROOTCLUS

	;STEP 6: CALCULATE THE SEECTOR NUMBER AND STORE IT
	
	;SET OLD EBX(ON THE STACK) TO CLUSTER NUMBER
	MOV DWORD [ESP+16], EAX

	;STEP 6.1: CALCULATE THE SECTOR NUMBER


	;SOME MULTIPLY OPERATIONS
	MOVZX ECX, BYTE [BPB_SECPERCLUS]
	MUL ECX

	;EAX IS NOW ((CLUSTER NUMBER)*(SECTOR PER CLUSTER))
	ADD EAX, FIRSTDATASECTOR
	
	;EAX IS NOW THE SECTOR NUMBER!!!

	;WRITE SECTOR NUMBER(OLD EAX) ONTO STACK!!!
	MOV DWORD [ESP+28], EAX


	POPAD

	RET