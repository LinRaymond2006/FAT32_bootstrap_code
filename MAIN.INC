;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;FUNCTION "READ_ATA"
;EAX:SECTOR OFFSET
;EBX:BUFFER LOCATION
;CX:NUMBER OF SECTORS TO READ

;RETURNS:NONE

%DEFINE BASE_PORT 0X1F0
;0X1F0:ATA0-MASTER
;READING VIA LBA24


READ_ATA:
	PUSHAD
	PUSH EAX
	MOV DI, CX
	MOV DX, BASE_PORT + 2
	MOV AL, CL
	OUT DX, AL 		;HOW MANY SECTORS TO READ
	POP EAX
	MOV DX, BASE_PORT + 3
	OUT DX, AL  	;LBADDR 0~7
	MOV CL, 8
	SHR EAX, CL
	MOV DX, BASE_PORT + 4
	OUT DX, AL  	;LBADDR 8~15
	SHR EAX, CL
	MOV DX, BASE_PORT + 5
	OUT DX, AL  	;LBADDR 16~23
	SHR EAX, CL
	AND AL, 0XE0    ;BIT7~BIT4=1110->USING LBA
	OR AL, 0XE0
	MOV DX, BASE_PORT + 6
	OUT DX, AL
	MOV DX, BASE_PORT + 7
	MOV AL, 0X20
	OUT DX, AL  	;0X20->READ
	.DISKSTAT_BUSY: ;WRITE->COMMAND WORD PORT. READ->DISK STATUS
		NOP
		IN AL, DX
		AND AL, 0X88  ;BIT3=1->READY, BIT7=1->DISK IN BUSY
		CMP AL, 0X08
		JNZ .DISKSTAT_BUSY
		MOV AX, DI
		MOV DX, 256
		MUL DX
		MOV CX, AX
		;DI=LOADER_SECT_SIZE, EACH SECTOR IS COMPOSED BY 512 BYTES
		;THEREFORE NEED DI*512/2 TIMES TO FINISH THE OPERATION(2BYTES COMPRISE A WORD)
		MOV DX, BASE_PORT
	.CONTRD:
		IN AX, DX
		;;;;;;;;;;USE EBX INSTEAD OF BX TO ADDRESS IN UNREAL MODE WITH A20 ENABLED HERE!;;;;;;;;;;;;;;;;;;;;
		MOV [EBX], AX
		ADD EBX, 2
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		LOOP .CONTRD
	POPAD
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;FUNCTION "NXT_CLUSTER"
;EDX:CLUSTER NUMBER (AS A CALLER, THE CLUSTER NUMBER STARTS FROM 0)
;EBP:WHERE TO GO IF RECIEVE "EOF" VALUE

;RETURNS:
;EAX: THE SECTOR NUMBER OF THE CLUSTER
;EDX:NEXT CLUSTER NUMBER (THE CLUSTER NUMBER STARTS FROM 0)

;NECESSARY CONDITIONS:
;MACRO "FATBASE" HAVE TO BE DEFINED

NXT_CLUSTER:
	
	PUSHAD

	;REGISTER EXCEPT FOR EDX AND EAX ARE AVAILABLE

	MOV EAX, EDX

	;CLUSTER NUMBER STARTS FROM 2
	;THAT IS TO SAY, THE FIRST DATA SECTOR IS CLUSTER 2, AND SO ON.
	;BUT IN THIS FUNCTION, ASSUME CLUSTER NUMBER STARTS FROM 0 (THE FIRST DATA SECTOR IS CLUSTER 0)

	;STEP 1: IF THE FIRST DATA SECTOR IS CLUSTER 0, THAN PLUS 2
	ADD EAX, BPB_ROOTCLUS

	;STEP 2: LOCATE THE NXTCLUS ENTRY IN FAT TABLE 
	;NOW, THE EAX REGISTER IS THE CLUSTER NUMBER (STARTS FROM 2)

	;STEP 2.1: MUL EAX BY 4 ((OPERATOR *4) = (OPERATOR << 2))
	ROL EAX, 2

	;STEP 2.2: EAX = EAX + FATBASE
	ADD EAX, FATBASE

	;STEP 3:EXTRACT THE VALUE OF "NXTCLUSTER", WRITEBACK INTO EAX
	MOV EAX, DWORD [EAX]




	;STEP 4:COMPARE IF THE VALUE IS A VALID CLUSTER NUMBER

	.CMP_STOP:
		;RECIEVE:
		;EAX:PASSED BY "STEP 3"
		;EBP AS WHERE TO JUMP IF FINISHED (PASSED BY CALLEE OF NXT_CLUSTER, THEREFORE NOT NEED TO BE SET)
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;IF NEXTCLUSTER IS VALID CLUSTER(NOT STOP_SIGNAL): JMP LOADROOTDIR
		;FAT[0]: SAME AS  MEDIA DESCRIPTOR
		;FAT[1]: OCCUPIED
		;FAT[N] VALUE (NOT ALL OF THEM ARE LISTED):
		;	0X0000002~0XFFFFFEF:NEXT CLUSTER
		;	0XFFFFFF8~0XFFFFFFF:EOF	
		;NOTE:ASSUME NO BAD CLUSTERS (ONLY VALID CLUSTER OR EOF)
		CMP EAX, 0X2
		JGE .IN_VALID_CLUSTERNUM_RANGE
		.IN_VALID_CLUSTERNUM_RANGE:CMP EAX, 0XFFFFFEF
		JBE .VALID_CLUSTER_NUMBER	;FINISH READING, RETURN
		.NOT_VALID_COMPARE_EOF: CMP EAX, 0XFFFFFF8
		JGE .IN_EOF_VALUE_RANGE
		.IN_EOF_VALUE_RANGE: CMP EAX, 0XFFFFFFF
		JBE .RETURN


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	.VALID_CLUSTER_NUMBER:

	;THESE WILL BE EXECUTED IF .CMP_STOP IS PASSED (A VALID DATA CLUSTER VALUE)

	;STEP 5: SUBSTRACT THE VALUE WITH "BPB_ROOTCLUS"
	SUB EAX, BPB_ROOTCLUS

	;STEP 6: CALCULATE THE SEECTOR NUMBER AND STORE IT
	
	;SET OLD EDX(ON THE STACK) TO CLUSTER NUMBER
	MOV DWORD [ESP+20], EAX

	;STEP 6.1: CALCULATE THE SECTOR NUMBER


	;SOME MULTIPLY OPERATIONS
	MOVZX ECX, BYTE [BPB_SECPERCLUS]
	MUL ECX

	;EAX IS NOW ((CLUSTER NUMBER)*(SECTOR PER CLUSTER))
	ADD EAX, FIRSTDATASECTOR
	
	;EAX IS NOW THE SECTOR NUMBER!!!

	;WRITE SECTOR NUMBER(OLD EAX) ONTO STACK!!!
	MOV DWORD [ESP+28], EAX

	.RETURN:
	POPAD

	;***NOT TESTED***
	ADD SP, 2 	;RETURN TO THE CALLEE OF THE CALLEE 
	;***NOT TESTED***

	RET


;;;;;;;;;;;;;;;;;;;;;;
;FUNCTION "LOAD_FILE"
;NOTE:LOADING A LOADER IN THIS CASE, BUT THE CALLEE SHOULD JUMP ONTO THE LOADER IN CS:OFFSET FORMAT!

;PASSED VALUES:

;SITUATION 1:LOADING A REGULAR FILE
;EDI: POINTER THAT POINTS TO THE FILENAME (MUST BE IN 8.3 FORMAT)

;SITUATION 2:LOADING THE ROOTDIRECTORY
;EDI ==0
;EDX HOLD THE FIRST CLUSTER NUMBER

;MACROS NEEDED:
;MACRO "ROOTBASE": WHERE THE ROOT DIRECTORY IS MAPPED IN MEMORY (WILL START LOOKING FROM THERE)
;MACRO "FATBASE": WHERE THE FAT TABLE IS MAPPED IN MEMORY
;MACRO "SFNSZ" (AS A CONST, IT IS NOT MANDATORY TO BE SET)
;NECESSARY CONDITIONS:
;THE FAT TABLE AND THE ROOTDIRECTORY FIELD MUST BE LOADED
;FIRSTDATASECTOR MUST BE CALCULATED
%IFNDEF SFNSZ
%DEFINE SFNSZ 32
%ENDIF
LOAD_FILE:
	PUSHAD
	;EVERYTHING CAN BE USED EXCEPT FOR EDI, WHICH HOLD A POINTER TO THE FILENAME

	;STEP 1:JUDGE THE CONDITION
	CMP EDI, 0
	JE .LOAD_ROOTDIR
	;ELSE:GOTO .LOAD_REGULAR_FILE
	;***IMPORTANT*** SOME CODE THAT LOADS FILE CAN BE USEFUL TO LOAD ROOTDIR (JUST A FILE STARTS AT CLUSTER 0)


	MOV ESI, ROOTDIRBASE
	MOV EBP, ESI 	;EBP IS THE BACKUP OF THE POINTER OF FILENAME INSIDE ROOT DIRECTORY
	MOV EDX, EDI 	;EDX IS THE BACKUP OF THE FILENAME THAT IS PASSED TO "LOAD_FILE"
	.COMPARE_FILENAME
		;STEP 0:SET THE CX REGISTER TO 11 (FILENAME LENGTH)
		MOV ECX, 11

		;STEP 1: COMPARE THE FILENAME
		;THE NETWIDE ASSEMBLER SEEMS NOT ACCEPT THE BELOW INSTRUCTION, THEREFORE USE OPCODES INSTEAD
		;DATA32 REPE CMPSB BYTE PTR [ESI], BYTE PTR ES:[EDI]

		DB 0X66, 0XF3 ,0X67 ,0XA6

		;STEP 2: IF THE FILENAME MATCHES, CX WILL BE 0
		;USE JCXZ INSTUCTION, SO THE INSTUCTION "CMP CX, 0;JE ..." CAN BE IGNORED

		JCXZ .GET_FIRSTCLUSTER

		;ELSE: THE FILENAME DOES NOT MATCH!

		;STEP 3: CHECK IF THE RANGE IS INSIDE ROOT DIRECTORY IN MEMORY:
		;NOTE:THE BUFFERBASE AND ROOTDIRBASE MUST BE THE SAME, THEREFORE WILL NOT NEED TO HANDLE EXCEPTION
		CMP ESI, ((ROOTDIRLIMIT-ROOTDIRBASE)-SFNSZ)
		;GREATER OR EQUAL INDICATES THE SFN ENTRY IS THE LAST ONE IN ROOTDIR
		JGE .FILE_LOST

		;STEP 4:RESET THE VALUE, AND CONTINUE COMPARING!

		ADD EBP, SFNSZ
		MOV ESI, EBP
		MOV EDI, EDX
		JMP .COMPARE_FILENAME

	.FILE_FOUND:

		.LOAD_ROOTDIR:
			XOR EDX, EDX
			JMP .EVERYTHING_DONE_START_LOADING_FILE

		.GET_FIRSTCLUSTER:
			;ESI IS NOW THE FILE ENTRY
			;THE START OF THE SFN ENTRY (OFFSET 0)=ESI-11
			;DIR_FSTCLUSHI STARTS FROM OFFSET 20, SIZE 2 (16BITS)
			;DIR_FSTCLUSLO STARTS FROM OFFSET 26, SIZE 2 (16BITS)
			;ALL IN ALL:
			;DIR_FSTCLUSHI=ESI-11+20=ESI+9
			;DIR_FSTCLUSLO=ESI-11+26=ESI+15
			MOV DX, WORD [ESI+9]
			SHL EDX, 16
			MOVZX ECX, WORD[ESI+15]
			ADD EDX, ECX


		.EVERYTHING_DONE_START_LOADING_FILE:

			;EVERYTHING IS SET, GO ON!
			;REFERNCE OF FUNCTION INTERFACE:

			;FUNCTION "NXT_CLUSTER"
				;EDX:CLUSTER NUMBER (AS A CALLER, THE CLUSTER NUMBER STARTS FROM 0)
				;EBP:WHERE TO GO IF RECIEVE "EOF" VALUE

				;RETURNS:
				;EAX: THE SECTOR NUMBER OF THE CLUSTER
				;EDX:NEXT CLUSTER NUMBER (THE CLUSTER NUMBER STARTS FROM 0)

			;FUNCTION "READ_ATA"
				;EAX:SECTOR OFFSET
				;EBX:BUFFER LOCATION
				;CX:NUMBER OF SECTORS TO READ

			;ESI AND EDI ARE FREE TO USE
			;EAX, EBX, ECX ARE USED BY "READ_ATA"
			;EDX IS USED BY "NXT_CLUSTER", HOLDS CLUSTER NUMBER
			;EBP: WHERE TO JUMP AFTER THE FILE IS LOADED

			.SETUP_WRITE_BUFFER:
			MOV EBX, [ESP+32]		;WHERE TO WRITE FROM
			MOVZX CX, BYTE [BPB_SECPERCLUS]

			.WRITE_BUFFER:
				CALL NXT_CLUSTER

				CALL READ_ATA
				
				JMP .WRITE_BUFFER


	.FILE_LOST:
		JMP $	;HALT!

	POPAD
	RET
